{"name":"Voila.GitHub.io","tagline":"","body":"# Weather API in OCaml\r\n\r\n\r\nI enjoyed Peter Bourgon's [How I Start](http://howistart.org/posts/go/1), Go seemed easy and fun. It made me wonder, how fun or easy would it be in OCaml? The only one way to find out is to do it!  (This post is not an OCaml tutorial, but I hope it gives an idea of what writing code in OCaml is like).    \r\n\r\n\r\n_Note: I've copied a lot from the original post, ideas and words. Any mistake or error are my own._\r\n\r\n\r\n## What is OCaml ?\r\n\r\nOCaml belongs to the ML language family (whose roots go back to the 70's), it has been used  in compilers, static analysis tools, and proof systems.\r\nIt is typed, functional with some imperative features, has a powerful module system, and an object system.\r\n\r\nOCaml is not super trendy. Yet recently, a great introductory [book](https://realworldocaml.org/) came out, and a new [website](http://ocaml.org/) launched. It's also made the news ([Coq](http://awards.acm.org/software_system/), [Hack](https://code.facebook.com/posts/264544830379293/hack-a-new-programming-language-for-hhvm/) and [Flow](https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/)).\r\n\r\n\r\n\r\nLet's use OCaml to build a backend service for a web app.\r\n\r\n1. [Setting up your environment](#setting-up-your-environment)\r\n1. [A new project](#a-new-project)\r\n1. [Making a web server](#making-a-web-server)\r\n1. [Adding more routes](#adding-more-routes)\r\n1. [Querying multiple APIs](#querying-multiple-apis)\r\n1. [Conclusion](#conclusion)\r\n1. [Further exercises](#further-exercises)\r\n\r\n## Setting up your environment\r\n\r\nThe first step is, of course, to install [OCaml and OPAM](http://opam.ocaml.org/doc/Quick_Install.html) (a package manager for OCaml). \r\n\r\nHere's how to go about it, on a recent Ubuntu:\r\n\r\n```\r\n$ sudo apt-get install software-properties-common \r\n$ sudo apt-get install m4 \r\n$ sudo apt-get install make\r\n$ sudo add-apt-repository ppa:avsm/ppa\r\n$ sudo apt-get update\r\n$ sudo apt-get install ocaml ocaml-native-compilers camlp4-extra opam\r\n$ opam init\r\n```\r\n\r\n Once you're done, this should work:\r\n \r\n```\r\n$ ocaml -version\r\nThe OCaml toplevel, version 4.02.1\r\n```\r\n\r\n\r\nThere are a few options for editing OCaml code (Emacs, Vim, SublimeText, and [more](https://code.facebook.com/posts/1505962329687926/flow-a-new-static-type-checker-for-javascript/))\r\nPersonally, I use Emacs with [tuareg](https://github.com/ocaml/tuareg) and [merlin](https://github.com/the-lambda-church/merlin)\r\n\r\nOCaml includes a bare bones top level, but you can use [utop](https://github.com/diml/utop), for a more capable one.\r\n\r\n\r\n## A new project\r\n\r\nCreate `hello.ml`, this will be our simplest OCaml program.\r\n\r\n```ocaml\r\nlet _ = print_endline \"hello!\"\r\n```\r\nCompile and run:\r\n\r\n```\r\n$ ocamlbuild hello.native\r\n$ ./hello.native\r\nhello!\r\n```\r\n\r\nEasy!\r\n\r\n## Making a web server\r\n\r\nLet's turn our \"hello\" program into a web server.\r\n\r\nBecause the HTTP library I'm using ([CoHTTP](https://github.com/mirage/ocaml-cohttp)) only support async code, we'll go straight into an asynchronous web server. With CoHTTP, we'll be using [Lwt](http://ocsigen.org/lwt/), a cooperative threads library.\r\n\r\nto install these two, do :\r\n\r\n```\r\n$ apt-get install libssl-dev\r\n$ opam install lwt.2.4.6 cohttp.0.12.0\r\n```\r\n\r\nThis should pull in all required dependencies\r\n\r\nHere's the full program for a simple 'hello' server.\r\n     \r\n```ocaml\r\nopen Lwt\r\nopen Cohttp\r\nopen Cohttp_lwt_unix\r\n\r\nlet make_server () =\r\n  let callback conn_id req body =\r\n    let uri = Request.uri req in\r\n    match Uri.path uri with\r\n    | \"/\" -> Server.respond_string ~status:`OK ~body:\"hello!\\n\" ()\r\n    | _ -> Server.respond_string ~status:`Not_found ~body:\"Route not found\" ()\r\n  in\r\n  let conn_closed conn_id () = () in\r\n  Server.create { Server.callback; Server.conn_closed }\r\n\r\nlet _ =\r\n  Lwt_unix.run (make_server ())\r\n```\r\n\r\nFirst, we open 3 modules, so we can use unqualified identifiers (for instance, `Request.uri` instead of `Cohttp.Request.uri`):\r\n\r\nIn `make_server()`, we create a server configured by 2 handler functions: `callback` to handle the request, and `conn_closed` to handle the end of the connection (here, we chose to do nothing).\r\n\r\ncallback takes a connection id, an HTTP request and a body. It dispatches on the request uri: \"/\" gets a hello response, anything else gets a 404.\r\n\r\nthe last expression is the program main entry,  `make_server` returns an Lwt thread.\r\n`Lwt_unix.run` runs this thread until it terminates\r\n\r\nTo compile this program, we first create the following _tag file:\r\n\r\n```\r\ntrue: package(lwt), package(cohttp), package(cohttp.lwt)\r\n```\r\nIt lists all the packages we're depending on\r\nNow that ocamlbuild can find the libraries we're using, we compile and run:\r\n\r\n```\r\n$ ocamlbuild -use-ocamlfind hello_server.native\r\n$ ./hello_server.native\r\n```\r\n\r\nTo interact with the server, in another terminal or your browser, make an HTTP request:\r\n\r\n```\r\n$ curl http://localhost:8080\r\nhello!\r\n```\r\n\r\nThat wasn't too bad!\r\n\r\n## Adding more routes\r\n\r\nWe can do something more interesting than just say hello.\r\n\r\nLet's take a city as input, call out to a weather API, and forward a response with the temperature.\r\nThe [OpenWeatherMap](http://openweathermap.org/)\r\n provides a [simple and free API](http://openweathermap.org/api)\r\n for [current forecast info](http://openweathermap.org/current),\r\n which we can [query by city](http://api.openweathermap.org/data/2.5/weather?q=Tokyo).\r\nIt returns responses like this (partially redacted):\r\n\r\n```json\r\n{\r\n    \"name\": \"Tokyo\",\r\n    \"coord\": {\r\n        \"lon\": 139.69,\r\n        \"lat\": 35.69\r\n    },\r\n    \"weather\": [\r\n        {\r\n            \"id\": 803,\r\n            \"main\": \"Clouds\",\r\n            \"description\": \"broken clouds\",\r\n            \"icon\": \"04n\"\r\n        }\r\n    ],\r\n    \"main\": {\r\n        \"temp\": 296.69,\r\n        \"pressure\": 1014,\r\n        \"humidity\": 83,\r\n        \"temp_min\": 295.37,\r\n        \"temp_max\": 298.15\r\n    }\r\n}\r\n```\r\n\r\nTo stay close to the original Go code, we'll use [atdgen](https://github.com/mjambon/atdgen), a tool that generate OCaml code to (de)serialize JSON (a more light-weight alternative would be to directly use a JSON library like [yojson](https://github.com/mjambon/yojson)).    \r\n\r\nFirst, let's install atdgen:\r\n\r\n```\r\n$ opam install atdgen\r\n```\r\n\r\nNext, in `openweathermap.atd`, we'll define the following types to specify what we want to deserialize from the JSON response:\r\n\r\n```\r\ntype main = { temp: float }\r\ntype weather = { main: main; name: string }\r\n```\r\n\r\nWe can now use `atdgen` to generate the OCaml code: \r\n\r\n```\r\natdgen -t openweathermap.atd\r\natdgen -j openweathermap.atd\r\n```\r\n\r\nThis creates 2 OCaml modules: `Openweathermap_t` and `Openweathermap_j`.\r\nWhich we can use like this:\r\n\r\n```ocaml\r\nlet weather = Openweathermap_j.weather_of_string response in ...\r\n```\r\n\r\nNow let's write a function to query the API:\r\n\r\n```ocaml\r\nlet query city = \r\n  let open Openweathermap_j in\r\n  Client.get (Uri.of_string \r\n    (\"http://api.openweathermap.org/data/2.5/weather?q=\" ^ city))\r\n  >>= fun (_, body) -> Cohttp_lwt_body.to_string body\r\n  >>= fun s -> return (string_of_weather (weather_of_string s))\r\n\r\n```\r\n\r\nWriting asynchronous code with LWT is done by combining operations with the `>>=` operator. \r\n\r\nIn `f >>= fun x -> g x`, `g` is a \"callback\" which runs after `f` has completed, with the result of `f` (here bound to `x`) as input\". \r\n\r\nFor example, when in OCaml we write:\r\n```\r\n(Client.get uri) >>= fun (_, body) -> to_string body\r\n```\r\nin Javascript, we would write:\r\n\r\n```\r\nClient.get(uri, function(_, body){ return to_string(body); })\r\n```\r\n\r\nSee this [LWT tutorial](http://openmirage.org/wiki/tutorial-lwt) for more. \r\n \r\n\r\nHere's the complete program:\r\n\r\n```ocaml\r\nopen Lwt\r\nopen Cohttp\r\nopen Cohttp_lwt_unix\r\n\r\n    \r\nlet query city = \r\n  let open Openweathermap_j in\r\n  Client.get (Uri.of_string \r\n    (\"http://api.openweathermap.org/data/2.5/weather?q=\" ^ city))\r\n  >>= fun (_, body) -> Cohttp_lwt_body.to_string body\r\n  >>= fun s -> return (string_of_weather (weather_of_string s))\r\n\r\nlet make_server () =\r\n let callback conn_id req body =\r\n  let uri = Request.uri req in\r\n  match Re_str.(split_delim (regexp_string \"/\") (Uri.path uri)) with\r\n  | \"\"::\"weather\"::city::_ -> query city >>= fun json ->\r\n     let headers = \r\n       Header.init_with \"content-type\" \"application/json; charset=utf-8\" in\r\n     Server.respond_string ~headers ~status:`OK ~body:json ()\r\n  | _ ->\r\n    Server.respond_string ~status:`Not_found ~body:\"Route not found\" ()\r\n in\r\n let conn_closed conn_id () = () in\r\n Server.create { Server.callback; Server.conn_closed }\r\n\r\n\r\nlet _ = \r\n  Lwt_unix.run (make_server ())\r\n```\r\n\r\nIn our server handler, we match uri of the form \"/weather/city\" to an API call, and returns the temperature as JSON.\r\n\r\nNow we'll update the `_tags` file with our new dependencies:\r\n\r\n```\r\ntrue: package(lwt), package(cohttp), package(cohttp.lwt), package(atdgen), package(yojson), package(re.str)\r\n```\r\n\r\nBuild and run, as before.\r\n\r\n```\r\n$ ocamlbuild -use-ocamlfind weather.native\r\n$ ./weather.native\r\n```\r\n\r\n```\r\ncurl http://localhost:8080/weather/tokyo\r\n{\"main\":{\"temp\":285.92},\"name\":\"Tokyo\"}\r\n```\r\n\r\n## Querying multiple APIs\r\n\r\nMaybe we can build a more accurate temperature for a city, by querying and averaging multiple weather APIs.\r\nUnfortunately for us, most weather APIs require authentication.\r\nSo, get yourself an API key for [Weather Underground](http://www.wunderground.com/weather/api).\r\n\r\nSince we want the same behavior from all of our weather providers, we're going to encode this in a module signature:\r\n\r\n```ocaml\r\nmodule type Weather = sig\r\n    (** get city's temperature in kelvin *)\r\n    val get_temp : city:string -> float Lwt.t\r\nend\r\n```\r\n\r\nNow, we can provide our old OpenWeatherMap query function in a module that satisfies this signature.\r\n\r\nAnd we'll add a simple line of logging, so we can see what's happening.\r\n\r\n```ocaml\r\n(** OpenWeatherMap Provider *)\r\nmodule OpenWeatherMap : Weather = struct\r\n  open Openweathermap_j\r\n  \r\n  let get_temp ~city = \r\n  Client.get (Uri.of_string \r\n    (\"http://api.openweathermap.org/data/2.5/weather?q=\" ^ city))\r\n  >>= fun (_, body) -> Cohttp_lwt_body.to_string body\r\n  >>= fun s -> \r\n    let w = weather_of_string s in \r\n    let temp = w.main.temp in\r\n    Lwt_io.printf \"openWeatherMap: %s: %.2f\\n\" city temp \r\n  >>= fun _ -> return temp\r\n  \r\nend\r\n\r\n```\r\n\r\nLet's do the same for the Weather Underground.\r\n\r\nHere's how the response looks (partially redacted):\r\n\r\n```\r\n{\r\n  \"response\": {\r\n    \"version\": \"0.1\",\r\n    \"termsofService\": \"http://www.wunderground.com/weather/api/d/terms.html\",\r\n    \"features\": {\r\n    \"conditions\": 1\r\n    }\r\n  },\r\n  \"current_observation\": {\r\n  ...\r\n  \"estimated\": {},\r\n  \"station_id\": \"KCASANFR58\",\r\n  \"observation_time\": \"Last Updated on June 27, 5:27 PM PDT\",\r\n  \"observation_time_rfc822\": \"Wed, 27 Jun 2012 17:27:13 -0700\",\r\n  \"observation_epoch\": \"1340843233\",\r\n  \"local_time_rfc822\": \"Wed, 27 Jun 2012 17:27:14 -0700\",\r\n  \"local_epoch\": \"1340843234\",\r\n  \"local_tz_short\": \"PDT\",\r\n  \"local_tz_long\": \"America/Los_Angeles\",\r\n  \"local_tz_offset\": \"-0700\",\r\n  \"weather\": \"Partly Cloudy\",\r\n  \"temperature_string\": \"66.3 F (19.1 C)\",\r\n  \"temp_f\": 66.3,\r\n  \"temp_c\": 19.1,\r\n  ...\r\n  }\r\n}\r\n```\r\n\r\nFirst let's define a new atdgen specification in `weatherunderground.atd`, just to get at `temp_c`:\r\n\r\n```\r\ntype current_observation = { temp_c: float }\r\ntype conditions = { current_observation: current_observation }\r\n```\r\n\r\nand like before, we generate the OCaml code:\r\n\r\n```\r\natdgen -t weatherunderground.atd\r\natdgen -j weatherunderground.atd\r\n```\r\n\r\nWe also need to provide an API key.\r\nWe'll define the key in the module, and use it in the `get_temp` function.\r\n\r\n(Note that the Weather Underground doesn't disambiguate cities quite as nicely as OpenWeatherMap.\r\nWe're skipping some important logic to handle ambiguous city names for the purposes of the example.)\r\n\r\n```ocaml\r\n(** WeatherUnderground Provider *)\r\nmodule WeatherUnderground : Weather = struct\r\n  open Weatherunderground_j\r\n  \r\n  let key = \"...\" (* your WU API key *)\r\n  \r\n  let kelvin_of_celsius t = t +. 273.15\r\n  \r\n  let get_temp ~city = \r\n  Client.get (Uri.of_string (\"http://api.wunderground.com/api/\" ^ \r\n    key ^ \"/conditions/q/\" ^ city ^ \".json\"))\r\n  >>= fun (_, body) -> Cohttp_lwt_body.to_string body\r\n  >>= fun s -> \r\n    let c = conditions_of_string s in \r\n    let temp = kelvin_of_celsius c.current_observation.temp_c in\r\n    Lwt_io.printf \"WeatherUnderground: %s: %.2f\\n\" city temp \r\n  >>= fun _ -> return temp\r\n  \r\nend\r\n\r\n```\r\n\r\nNow that we have a couple of weather providers, let's write a function to query them all, and return the average temperature.\r\n\r\nFor simplicity, if we encounter any errors, we'll just give up. IS IT TRUE ?\r\n\r\nFirst we'll install `core`, to use its `Time` module (Core is a modernized OCaml standard library from Jane Street). Be aware that installing it can take a few minutes...\r\n\r\n```\r\n$ opam install core\r\n```\r\n\r\nNext, in `response.atd`, we'll define a type to describe the JSON response.\r\n\r\n```\r\ntype response = { city: string; temp: float; took: string; }\r\n```\r\n\r\nAgain, we generate the boilerplate OCaml code:\r\n\r\n```\r\n$ atdgen -t response.atd\r\n$ atdgen -j response.atd\r\n```\r\n\r\nNow let's write the function `temperature`. \r\nIt takes a city name and a list of provider functions\r\nlooking at their type, val get_temp : city:string -> float Lwt.t\r\n\r\n```ocaml\r\nlet average xs =\r\n  let sum = List.fold_left (+.) 0. xs in\r\n  (sum /. float_of_int (List.length xs))\r\n    \r\n\r\nlet temperature ~city ~providers =\r\n  let open Response_j in \r\n  let open Core.Std in\r\n    let t0 = Time.now () in\r\n    Lwt_list.map_p (fun get_temp -> get_temp ~city) providers >>= \r\n      fun temps -> \r\n        let t1 = Time.now () in\r\n        let response = { city = city; temp = average temps; \r\n                         took = Core.Span.to_string (Time.diff t1 t0); }\r\n        in return (string_of_response response)\r\n```\r\n\r\nWe use `Lwt_list.map_p` to fire off queries in parallel.\r\nOnce the longest queries is finished, we return the average temperature\r\nand the time it took. \r\n\r\nNotice that the function definition is very close to the weatherProvider temperature method.\r\nIf we collect the individual weatherProviders into a type, and define the temperature method on that type,\r\nwe can implement a meta-weatherProvider, comprised of other weatherProviders.\r\n\r\n\r\nNow, we can wire that up to our HTTP server.\r\n\r\n```\r\nlet make_server temp =\r\n let callback conn_id req body =\r\n  let uri = Request.uri req in\r\n  match Re_str.(split_delim (regexp_string \"/\") (Uri.path uri)) with\r\n  | \"\"::\"weather\"::city::_ -> temp ~city >>= fun json ->\r\n     let headers = \r\n       Header.init_with \"content-type\" \"application/json; charset=utf-8\" in\r\n     Server.respond_string ~headers ~status:`OK ~body:json ()\r\n  | _ ->\r\n    Server.respond_string ~status:`Not_found ~body:\"Route not found\" ()\r\n in\r\n let conn_closed conn_id () = () in\r\n Server.create { Server.callback; Server.conn_closed }\r\n\r\n\r\nlet _ = \r\n  let providers = [OpenWeatherMap.get_temp; WeatherUnderground.get_temp;] \r\n  in Lwt_unix.run (make_server (temperature ~providers))\r\n```\r\n\r\nNote that we pass a partially applied `temperature` function to `make_server`.\r\n\r\nNow we'll update our `_tags` file:\r\n\r\n```\r\ntrue: package(core), package(lwt), package(cohttp), package(cohttp.lwt), package(atdgen), package(yojson), package(re.str), thread\r\n```\r\n\r\nFinally we compile, run, and GET, just as before.\r\nIn addition to the JSON response, you'll see the following output.\r\n\r\n```\r\n$ ./weather.native\r\nopenWeatherMap: tokyo: 287.11\r\nWeatherUnderground: tokyo: 288.15\r\n```\r\n\r\n```\r\n$ curl http://localhost/weather/tokyo\r\n{\"city\":\"tokyo\",\"temp\":287.63,\"took\":\"611.787ms\"}\r\n```\r\n\r\n## Conclusion \r\n\r\nSo in the end, was it as easy and fun as Go ?\r\n\r\nWell... I have to admit that OCaml is much less \"batteries included\" than Go: we had to install libraries for the http server, JSON serialization, and even time operations.\r\n\r\nAlso building the program is more involved.\r\n\r\nThe concurrent code with LWT takes some time to get used to, but I am not familiar enough with Go's concurrency to judge which one is easier.\r\n\r\nSo probably not as easy overall... \r\n\r\nI did have fun though :)\r\n\r\n\r\n## Further exercises\r\n\r\n[Fork](https://github.com/voila/weather-api-ocaml) the final code on github.\r\n\r\nCan you add some error handling (for instance, can you prevent the failure of one weather provider from aborting the whole computation) ?\r\n\r\nCan you add another weather provider? (Hint: [forecast.io](https://developer.forecast.io/) is a good one)\r\n\r\nCan you implement a timeout?","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}